# XS-002 技术规格文档

## 文档信息

- **文档编号**: XS-002
- **文档标题**: 技术规格文档
- **创建日期**: 2024-12-19
- **文档类型**: 详细设计文档
- **状态**: 待评审
- **基于文档**: XS-001 可行性分析报告、XS-003 ever-gauzy 架构设计分析

---

## 1. 项目概述

### 1.1 项目定位

**oksai.api** 是一个**纯后端应用**，专注于提供 REST API 和 GraphQL API 服务，不包含任何前端实现。

- **项目类型**: Monorepo（使用 pnpm workspace）
- **项目目标**: 提供高性能、可扩展的后端 API 服务
- **服务对象**: 前端应用、移动应用、第三方系统等客户端
- **架构模式**: 传统三层架构 + CQRS + 事件驱动架构（EDA）
  - **说明**: 架构模式基于参考项目 ever-gauzy 的实际实现
  - **架构特点**: 按功能模块组织，而非严格的分层架构

### 1.2 核心特性

- ✅ 纯后端服务，不包含前端代码
- ✅ REST API 和 GraphQL API 双协议支持（MVP 阶段）
- ✅ 传统三层架构（Controller-Service-Repository）
- ✅ CQRS 模式实现命令查询分离
- ✅ 事件驱动架构支持异步通信（事件持久化为未来扩展）
- ✅ 插件化架构支持功能扩展（必需功能）
- ✅ 多租户支持（必需功能）
- ✅ 完整的认证授权体系

### 1.3 功能优先级

#### MVP 阶段（必需功能）

以下功能必须在 MVP 阶段实现：

- **REST API 支持**: 提供完整的 RESTful API 接口
- **GraphQL API 支持**: 提供 GraphQL 查询和变更接口
- **传统三层架构**: Controller-Service-Repository 分层架构
- **CQRS 模式**: 命令查询职责分离
- **事件驱动架构（EDA）**: 基于内存事件总线的异步通信
- **插件系统**: 完整的插件化架构，支持功能扩展
- **多租户支持**: 完整的多租户数据隔离和上下文管理
- **认证授权体系**: JWT 认证和 RBAC 授权
- **MikroORM 支持**: 使用 MikroORM 作为数据访问层（保留 ORM 抽象层作为扩展点）

#### 可选功能

以下功能为可选功能，根据项目需求决定是否实现：

- **WebSocket 支持**: 基于 Socket.io 的实时通信（参考 ever-gauzy 实现，使用 `@nestjs/platform-socket.io`）

#### 未来扩展计划

以下功能计划在未来版本中实现：

- **事件持久化存储**: 实现事件存储和重放机制，支持完整的事件溯源（ES）
- **TypeORM 支持**: 通过 ORM 抽象层扩展支持 TypeORM（当前抽象层已预留接口）

### 1.4 参考项目

本项目基于 **ever-gauzy** 项目的后端代码进行提取和重构：
- 参考项目：ever-gauzy（企业级业务管理平台）
- 提取范围：仅后端代码（`apps/api`、`packages/core` 等）
- 排除范围：所有前端代码（Angular 应用、UI 组件等）

---

## 2. 技术栈

### 2.1 核心技术

| 技术类别 | 技术选型 | 版本要求 | 说明 |
|---------|---------|---------|------|
| **运行时** | Node.js | >= 20.0.0 | LTS 版本 |
| **编程语言** | TypeScript | ^5.7.3 | 严格模式 |
| **框架** | NestJS | ^11.0.0 | 企业级 Node.js 框架 |
| **包管理** | pnpm | 10.17.0 | Monorepo 支持 |
| **构建工具** | Turbo | ^2.0.0 | Monorepo 构建和缓存（参考项目使用 Nx，本项目使用 Turbo） |

### 2.2 数据库

| 数据库类型 | 技术选型 | 版本要求 | 说明 |
|----------|---------|---------|------|
| **关系型数据库** | PostgreSQL | >= 14.0 | 主数据库 |
| **ORM** | MikroORM | ^6.5.8 | 数据库访问层（保留 ORM 抽象层，未来可扩展 TypeORM） |
| **缓存** | Redis | >= 6.0 | 缓存和会话存储 |

### 2.3 API 协议

- **REST API**: 基于 NestJS 的 RESTful 接口
- **GraphQL**: 基于 Apollo Server 的 GraphQL 接口
- **WebSocket**: 基于 Socket.io 的实时通信（可选功能，参考 ever-gauzy 实现）

### 2.4 开发工具

- **代码检查**: ESLint（基于 `@eslint/eslintrc`）
- **代码格式化**: Prettier
- **测试框架**: Jest
- **类型检查**: TypeScript Compiler
- **Git Hooks**: Husky

### 2.5 基础设施

- **容器化**: Docker + Docker Compose
- **进程管理**: PM2（生产环境）
- **日志**: 基于 NestJS LoggerService 的默认日志实现（参考 ever-gauzy 的 DefaultLogger）
- **外部日志服务**: Sentry、PostHog（通过插件系统集成，可选）
- **监控**: OpenTelemetry（可选，通过环境变量 `OTEL_ENABLED` 控制）

---

## 3. 架构设计

### 3.1 架构模式

本项目采用**混合架构模式**，基于参考项目 ever-gauzy 的实际实现：

1. **传统三层架构（Controller-Service-Repository）**
   - **Controller 层**: 处理 HTTP 请求，参数验证，响应格式化
   - **Service 层**: 业务逻辑处理，事务管理
   - **Repository 层**: 数据访问，数据库操作
   - **组织方式**: 按功能模块组织，而非严格的分层架构

2. **CQRS（命令查询职责分离）**
   - **命令（Command）**: 写操作，修改状态，通过 Command Handlers 处理
   - **查询（Query）**: 读操作，查询数据，通过 Query Handlers 处理
   - **读写分离**: 优化性能，支持不同的数据模型

3. **事件驱动架构（EDA）**
   - **事件总线（Event Bus）**: 基于 RxJS Subject 的内存事件流
   - **发布-订阅模式**: 跨模块异步通信
   - **事件处理器**: 处理业务事件
   - **当前状态**: 事件仅在内存中流转，未实现事件持久化存储
   - **未来扩展**: 计划实现事件持久化存储，支持完整的事件溯源（ES）功能

### 3.2 三层架构

```
┌─────────────────────────────────────┐
│      Controller 层（接口层）           │
│  - REST Controllers                  │
│  - GraphQL Resolvers                 │
│  - WebSocket Gateways（可选）         │
│  - 参数验证、响应格式化                │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      Service 层（业务逻辑层）          │
│  - 业务逻辑处理                       │
│  - 事务管理                          │
│  - Command/Query Handlers            │
│  - Event Handlers                    │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   Repository 层（数据访问层）          │
│  - MikroORM Repositories（当前实现）  │
│  - ORM 抽象层（未来可扩展 TypeORM）    │
│  - 数据库操作                        │
│  - 查询构建                          │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│      基础设施层                       │
│  - Database (PostgreSQL)            │
│  - Event Bus                        │
│  - External Services                │
└─────────────────────────────────────┘
```

**架构说明**：
- 本架构基于 ever-gauzy 的实际实现，采用传统三层架构而非严格的 Clean Architecture
- 按功能模块组织代码（如 `user`、`task`、`organization`），每个模块包含完整的 Controller、Service、Repository
- Entity 直接继承 ORM 基类，与数据库紧密耦合
- 没有明确的领域层抽象和依赖倒置

### 3.3 模块组织

本项目按**功能模块**组织代码，每个模块包含完整的三层结构：

```
apps/
├── api/                    # 主 API 应用
│   ├── src/
│   │   ├── main.ts         # 应用入口
│   │   ├── app.module.ts   # 根模块
│   │   └── ...
│   └── package.json
│
libs/
├── core/                   # 核心业务框架
│   ├── src/
│   │   └── lib/            # 功能模块目录
│   │       ├── user/       # 用户模块
│   │       │   ├── user.entity.ts
│   │       │   ├── user.service.ts
│   │       │   ├── user.controller.ts
│   │       │   ├── repository/
│   │       │   ├── commands/
│   │       │   ├── queries/
│   │       │   └── dto/
│   │       ├── tasks/      # 任务模块
│   │       ├── organization/ # 组织模块
│   │       ├── employee/   # 员工模块
│   │       ├── event-bus/  # 事件总线
│   │       ├── database/   # 数据库配置
│   │       └── ...
│   └── package.json
│
├── auth/                   # 认证授权模块
├── common/                  # 通用工具
├── config/                  # 配置管理
├── constants/               # 常量定义
├── contracts/               # 接口契约
└── utils/                   # 工具函数
```

**模块组织特点**：
- 按功能模块组织，而非按分层组织
- 每个模块包含完整的 Controller、Service、Repository
- 模块之间通过依赖注入和事件总线通信
- 共享的基础设施（如数据库、事件总线）放在 `core/lib` 根目录

### 3.4 CQRS 实现

#### 3.4.1 Command 定义

```typescript
/**
 * 用户创建命令
 *
 * @description
 * 表示创建用户的命令，包含创建用户所需的所有信息。
 */
export class UserCreateCommand implements ICommand {
  static readonly type = '[User] Create';
  
  constructor(public readonly input: IUserCreateInput) {}
}
```

#### 3.4.2 Command Handler

```typescript
/**
 * 用户创建命令处理器
 *
 * @description
 * 处理用户创建命令，执行用户创建的业务逻辑。
 */
@CommandHandler(UserCreateCommand)
export class UserCreateHandler implements ICommandHandler<UserCreateCommand> {
  constructor(
    private readonly _userService: UserService,
    private readonly _eventBus: EventBus
  ) {}

  async execute(command: UserCreateCommand): Promise<IUser> {
    const { input } = command;
    
    // 创建用户
    const user = await this._userService.create(input);
    
    // 发布事件
    await this._eventBus.publish(new UserCreatedEvent(user.id));
    
    return user;
  }
}
```

#### 3.4.3 Query 定义

```typescript
/**
 * 获取用户查询
 *
 * @description
 * 表示获取用户信息的查询。
 */
export class GetUserQuery implements IQuery {
  static readonly type = '[User] Get';
  
  constructor(public readonly id: string) {}
}
```

#### 3.4.4 Query Handler

```typescript
/**
 * 获取用户查询处理器
 *
 * @description
 * 处理获取用户查询，返回用户信息。
 */
@QueryHandler(GetUserQuery)
export class GetUserHandler implements IQueryHandler<GetUserQuery> {
  constructor(
    private readonly _userService: UserService
  ) {}

  async execute(query: GetUserQuery): Promise<IUser> {
    return await this._userService.findOneByIdString(query.id);
  }
}
```

#### 3.4.5 CQRS 使用

```typescript
@Controller('users')
export class UserController {
  constructor(
    private readonly _commandBus: CommandBus,
    private readonly _queryBus: QueryBus
  ) {}

  @Post()
  async create(@Body() dto: CreateUserDTO): Promise<IUser> {
    // 使用 Command Bus 执行命令
    return await this._commandBus.execute(new UserCreateCommand(dto));
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<IUser> {
    // 使用 Query Bus 执行查询
    return await this._queryBus.execute(new GetUserQuery(id));
  }
}
```

### 3.5 事件驱动架构

**功能状态**: ✅ **必需功能**（MVP 阶段必须实现），⏳ **事件持久化**（未来扩展计划）

事件驱动架构是本项目的核心功能之一，支持基于内存事件总线的异步通信。事件持久化存储计划在未来版本中实现。

#### 3.5.1 事件总线实现

```typescript
// 事件总线接口
interface EventBus {
  publish<T extends BaseEvent>(event: T): Promise<void>;
  ofType<T extends BaseEvent>(event: Type<T>): Observable<T>;
}

// 事件基类
abstract class BaseEvent {
  readonly id: string;
  readonly createdAt: Date;
}

// 使用示例
class TaskCreatedEvent extends BaseEvent {
  constructor(public readonly taskId: string) {
    super();
  }
}
```

#### 3.5.2 事件处理流程

1. **事件发布**: 业务操作触发事件发布
2. **事件路由**: 事件总线将事件路由到订阅者
3. **事件处理**: 事件处理器处理业务逻辑
4. **副作用**: 可能触发新的事件或外部调用

### 3.6 多租户架构

**功能状态**: ✅ **必需功能**（MVP 阶段必须实现）

多租户支持是本项目的核心功能之一，提供完整的数据隔离和上下文管理机制。

#### 3.6.1 多租户数据模型

**实体继承层次**：

```
BaseEntity
  ├── id: ID
  ├── createdAt: Date
  ├── updatedAt: Date
  └── deletedAt?: Date (软删除)

TenantBaseEntity extends BaseEntity
  ├── tenant?: Tenant
  └── tenantId?: ID

TenantOrganizationBaseEntity extends TenantBaseEntity
  ├── organization?: Organization
  └── organizationId?: ID
```

**实体定义示例**：

```typescript
/**
 * 多租户实体基类
 *
 * @description
 * 所有需要多租户隔离的实体应继承此类。
 * 自动添加 tenantId 字段，实现数据隔离。
 */
export abstract class TenantBaseEntity extends BaseEntity {
  @MultiORMManyToOne(() => Tenant, {
    nullable: true,
    onDelete: 'CASCADE'
  })
  tenant?: ITenant;

  @MultiORMColumn({ nullable: true, relationId: true })
  tenantId?: ID;
}
```

#### 3.6.2 请求上下文管理（CLS）

**RequestContext 实现**：

```typescript
/**
 * 请求上下文类
 *
 * @description
 * 使用 CLS (Continuation Local Storage) 管理请求级数据。
 * 每个请求都有独立的上下文，包含用户、租户、组织等信息。
 */
export class RequestContext {
  private static clsService: ClsService;
  
  private readonly _id: ID;
  private readonly _req: Request;
  private readonly _res: Response;
  private _user: IUser;
  private _tenantId: ID;
  private _organizationId: ID;

  /**
   * 获取当前请求上下文
   */
  static currentRequestContext(): RequestContext | null {
    // 从 CLS 获取当前请求上下文
  }

  /**
   * 获取当前用户
   */
  static currentUser(): IUser | null {
    const context = RequestContext.currentRequestContext();
    return context ? context.user : null;
  }

  /**
   * 获取当前租户 ID
   */
  static currentTenantId(): ID | null {
    const context = RequestContext.currentRequestContext();
    return context ? context.tenantId : null;
  }

  /**
   * 获取当前组织 ID
   */
  static currentOrganizationId(): ID | null {
    const context = RequestContext.currentRequestContext();
    return context ? context.organizationId : null;
  }
}
```

**多租户数据隔离**：

```typescript
/**
 * 多租户感知的 CRUD 服务基类
 *
 * @description
 * 自动为所有查询添加租户过滤条件，确保数据隔离。
 */
export abstract class TenantAwareCrudService<T extends TenantBaseEntity> 
  extends CrudService<T> {
  
  protected async findConditionsWithTenant(
    options: FindManyOptions<T>
  ): Promise<FindManyOptions<T>> {
    const tenantId = RequestContext.currentTenantId();
    
    if (tenantId) {
      // 自动添加租户过滤条件
      options.where = {
        ...options.where,
        tenantId
      };
    }
    
    return options;
  }
}
```

#### 3.6.3 多租户请求处理流程

1. **请求进入** → 解析 JWT Token
2. **提取租户信息** → 从 Token 或 Header 获取 `tenantId` 和 `organizationId`
3. **创建请求上下文** → 使用 CLS (nestjs-cls) 存储上下文
4. **数据访问** → Repository 自动添加租户过滤条件
5. **请求结束** → 自动清理上下文

### 3.7 ORM 抽象层与 MikroORM 支持

#### 3.7.1 设计说明

**ORM 抽象层设计**：

- **当前实现**: 本轮开发仅支持 MikroORM，作为主要数据访问层
- **抽象层保留**: 保留 ORM 抽象层作为扩展点，未来可扩展支持 TypeORM
- **设计目标**: 通过抽象层屏蔽不同 ORM 的差异，便于未来扩展

**ORM 类型枚举**：

```typescript
export enum MultiORMEnum {
  TypeORM = 'typeorm',      // 未来扩展支持
  MikroORM = 'mikro-orm'    // 当前实现
}

export type MultiORM = MultiORMEnum.TypeORM | MultiORMEnum.MikroORM;
```

**ORM 类型获取**：

```typescript
/**
 * 获取当前使用的 ORM 类型
 *
 * @description
 * 通过环境变量 DB_ORM 决定使用哪个 ORM。
 * 默认使用 MikroORM（当前唯一实现）。
 * TypeORM 支持为未来扩展计划。
 */
export function getORMType(): MultiORM {
  const dbORM = process.env.DB_ORM || 'mikro-orm';
  return dbORM === 'typeorm' 
    ? MultiORMEnum.TypeORM 
    : MultiORMEnum.MikroORM;  // 默认返回 MikroORM
}
```

#### 3.7.2 Repository 实现

**Repository 模式（当前实现）**：

```typescript
/**
 * 用户服务示例
 *
 * @description
 * 当前仅使用 MikroORM Repository。
 * 构造函数中保留 TypeORM Repository 参数位置，但实际不注入（或注入 null），
 * 为未来扩展 TypeORM 支持预留接口。
 */
@Injectable()
export class UserService extends TenantAwareCrudService<User> {
  constructor(
    readonly mikroOrmUserRepository: MikroOrmUserRepository,
    readonly typeOrmUserRepository: TypeOrmUserRepository | null = null  // 未来扩展
  ) {
    super(mikroOrmUserRepository, typeOrmUserRepository);
  }

  async findById(id: string): Promise<User> {
    // 当前实现：仅使用 MikroORM
    switch (this.ormType) {
      case MultiORMEnum.MikroORM:
        return await this.mikroOrmUserRepository.findOne({ id });
      case MultiORMEnum.TypeORM:
        // 未来扩展：TypeORM 实现
        throw new Error('TypeORM support is not implemented yet');
      default:
        return await this.mikroOrmUserRepository.findOne({ id });
    }
  }
}
```

#### 3.7.3 CRUD 基类抽象

```typescript
/**
 * CRUD 服务基类
 *
 * @description
 * 提供通用的 CRUD 操作，当前仅支持 MikroORM。
 * 保留 TypeORM Repository 参数位置，为未来扩展预留接口。
 * 根据配置自动选择使用 TypeORM 或 MikroORM（当前仅 MikroORM 可用）。
 */
export abstract class CrudService<T extends BaseEntity> {
  constructor(
    protected readonly mikroOrmRepository: MikroOrmBaseEntityRepository<T>,
    protected readonly typeOrmRepository: Repository<T> | null = null  // 未来扩展
  ) {}

  public get ormType(): MultiORM {
    return getORMType();
  }

  async findOne(options: FindOneOptions<T>): Promise<T | null> {
    switch (this.ormType) {
      case MultiORMEnum.MikroORM:
        // 当前实现：MikroORM
        return await this.mikroOrmRepository.findOne(
          parseTypeORMFindToMikroOrm(options)
        );
      case MultiORMEnum.TypeORM:
        // 未来扩展：TypeORM 实现
        if (!this.typeOrmRepository) {
          throw new Error('TypeORM repository is not available');
        }
        return await this.typeOrmRepository.findOne(options);
      default:
        // 默认使用 MikroORM
        return await this.mikroOrmRepository.findOne(
          parseTypeORMFindToMikroOrm(options)
        );
    }
  }

  async create(entity: DeepPartial<T>): Promise<T> {
    switch (this.ormType) {
      case MultiORMEnum.MikroORM:
        return await this.mikroOrmRepository.create(entity);
      case MultiORMEnum.TypeORM:
        if (!this.typeOrmRepository) {
          throw new Error('TypeORM repository is not available');
        }
        return await this.typeOrmRepository.save(entity);
      default:
        return await this.mikroOrmRepository.create(entity);
    }
  }
}
```

#### 3.7.4 查询构建器抽象

```typescript
/**
 * 统一查询构建器接口
 *
 * @description
 * 提供统一的查询构建接口，屏蔽不同 ORM 的差异。
 * 当前仅实现 MikroORM 查询构建器，TypeORM 构建器为未来扩展。
 */
export interface IQueryBuilder<T> {
  where(condition: string, parameters?: any): IQueryBuilder<T>;
  andWhere(condition: string, parameters?: any): IQueryBuilder<T>;
  orderBy(column: string, order?: 'ASC' | 'DESC'): IQueryBuilder<T>;
  take(limit: number): IQueryBuilder<T>;
  skip(offset: number): IQueryBuilder<T>;
  getMany(): Promise<T[]>;
  getOne(): Promise<T | null>;
}

/**
 * 创建 ORM 特定的查询构建器
 *
 * @description
 * 当前仅支持 MikroORM，TypeORM 支持为未来扩展计划。
 */
export function multiORMCreateQueryBuilder<T>(
  repository: any,
  ormType: MultiORMEnum,
  alias?: string
): IQueryBuilder<T> {
  switch (ormType) {
    case MultiORMEnum.MikroORM:
      return new MikroOrmQueryBuilder(repository, alias);
    case MultiORMEnum.TypeORM:
      // 未来扩展：TypeORM 查询构建器
      throw new Error('TypeORM query builder is not implemented yet');
    default:
      return new MikroOrmQueryBuilder(repository, alias);
  }
}
```

#### 3.7.5 实现说明

**当前实现状态**：

- ✅ **MikroORM**: 完整实现，作为主要数据访问层
- ⏳ **TypeORM**: 抽象层已预留接口，未来扩展计划
- ✅ **ORM 抽象层**: 已实现，支持未来扩展 TypeORM

**扩展计划**：

1. 实现 TypeORM Repository 适配器
2. 实现 TypeORM 查询构建器
3. 实现 TypeORM 到 MikroORM 的查询转换工具
4. 通过环境变量 `DB_ORM` 动态切换 ORM

### 3.8 插件系统

#### 3.8.1 插件架构

**插件配置接口**：

```typescript
export interface ApplicationPluginConfig {
  plugins?: Array<Type<IPlugin>>;
  dbConnectionOptions?: TypeOrmModuleOptions;
  dbMikroOrmConnectionOptions?: MikroOrmModuleOptions;
  // ... 其他配置
}
```

**插件定义接口**：

```typescript
export interface IPlugin {
  name: string;
  version: string;
  entities?: Array<Type<any>>;
  subscribers?: Array<Type<EntitySubscriberInterface>>;
  configuration?: (
    config: ApplicationPluginConfig
  ) => Promise<ApplicationPluginConfig>;
}
```

#### 3.8.2 插件注册流程

**预引导阶段**：

1. **注册插件实体**：检查冲突，合并到核心实体列表
2. **注册插件订阅者**：检查冲突，合并到核心订阅者列表
3. **应用插件配置**：执行插件的配置函数

**启动阶段**：

1. **加载插件模块**：动态加载插件 NestJS 模块
2. **注册插件服务**：注册插件提供的服务
3. **初始化插件功能**：执行插件初始化逻辑

**实体注册示例**：

```typescript
export async function preBootstrapRegisterEntities(
  config: Partial<ApplicationPluginConfig>
): Promise<Array<Type<any>>> {
  const coreEntitiesList = [...coreEntities];
  const pluginEntitiesList = getEntitiesFromPlugins(config.plugins);
  
  // 检查冲突
  const coreEntityNames = new Set(coreEntitiesList.map(e => e.name));
  for (const pluginEntity of pluginEntitiesList) {
    if (coreEntityNames.has(pluginEntity.name)) {
      throw new ConflictException(
        `Entity conflict: ${pluginEntity.name} conflicts with core entities.`
      );
    }
  }
  
  return [...coreEntitiesList, ...pluginEntitiesList];
}
```

#### 3.8.3 插件示例

```typescript
@Plugin({
  name: 'sentry-plugin',
  version: '1.0.0'
})
export class SentryPlugin implements IPlugin {
  entities = [SentryEventEntity];
  subscribers = [SentrySubscriber];
  
  async configuration(config: ApplicationPluginConfig) {
    // 应用 Sentry 配置
    config.dbConnectionOptions = {
      ...config.dbConnectionOptions,
      // Sentry 特定配置
    };
    return config;
  }
}
```

### 3.9 应用启动流程

#### 3.9.1 Bootstrap 流程

```
1. 预引导配置 (preBootstrapApplicationConfig)
   ├── 注册核心实体
   ├── 注册插件实体
   ├── 注册订阅者
   └── 应用插件配置

2. 创建 NestJS 应用
   ├── 加载 BootstrapModule
   └── 配置日志和中间件

3. 配置中间件
   ├── CORS
   ├── Session (Redis/内存)
   ├── Helmet (生产环境)
   └── 全局守卫

4. 数据库初始化
   ├── 连接数据库
   ├── 运行迁移
   └── 加载种子数据（如需要）

5. 启动服务器
   ├── 配置 Swagger
   └── 监听端口
```

#### 3.9.2 Bootstrap 代码结构

```typescript
/**
 * 启动 NestJS 应用程序
 *
 * @description
 * 本函数是应用的核心启动函数，负责应用初始化、中间件配置、
 * 数据库连接和服务器启动。
 */
export async function bootstrap(
  pluginConfig?: Partial<ApplicationPluginConfig>
): Promise<INestApplication> {
  // 1. 预引导配置
  const config = await preBootstrapApplicationConfig(pluginConfig);
  
  // 2. 创建应用
  const app = await NestFactory.create<NestExpressApplication>(BootstrapModule);
  
  // 3. 配置中间件
  app.enableCors({ /* ... */ });
  await configureRedisSession(app);
  app.useGlobalGuards(new AuthGuard(reflector));
  
  // 4. 数据库种子
  await seedDatabaseIfEmpty(app, appService);
  
  // 5. 启动服务器
  await app.listen(port, host);
  
  return app;
}
```

### 3.10 设计模式

#### 3.10.1 使用的设计模式

1. **依赖注入（Dependency Injection）**
   - 实现：NestJS 内置 DI 容器
   - 用途：管理服务依赖关系

2. **仓储模式（Repository Pattern）**
   - 实现：Repository 类封装数据访问
   - 用途：抽象数据访问层

3. **策略模式（Strategy Pattern）**
   - 实现：ORM 抽象层，当前支持 MikroORM，未来可扩展 TypeORM
   - 用途：通过抽象层屏蔽不同 ORM 的差异，便于未来扩展

4. **模板方法模式（Template Method Pattern）**
   - 实现：CrudService 基类
   - 用途：定义 CRUD 操作的骨架

5. **观察者模式（Observer Pattern）**
   - 实现：事件总线 + RxJS
   - 用途：解耦事件发布者和订阅者

6. **装饰器模式（Decorator Pattern）**
   - 实现：NestJS 装饰器
   - 用途：增强类和方法功能

---

## 4. 目录结构规范

### 4.1 Monorepo 结构

```
oksai.api/
├── apps/                    # 应用目录
│   └── api/                 # API 应用
│
├── libs/                    # 共享库目录
│   ├── core/                # 核心框架
│   ├── auth/                # 认证模块
│   ├── common/              # 通用工具
│   ├── config/              # 配置管理
│   ├── constants/           # 常量定义
│   ├── contracts/           # 接口契约
│   └── utils/               # 工具函数
│
├── tests/                   # 测试目录
│   ├── integration/          # 集成测试
│   └── e2e/                 # 端到端测试
│
├── docs/                    # 文档目录
├── examples/                # 参考示例
├── .docker/                 # Docker 配置
├── package.json             # 根 package.json
├── pnpm-workspace.yaml     # pnpm workspace 配置
├── turbo.json              # Turbo 配置
└── tsconfig.json           # TypeScript 配置
```

### 4.2 应用目录结构

```
apps/api/
├── src/
│   ├── main.ts              # 应用入口
│   ├── app.module.ts        # 根模块
│   ├── config/              # 应用配置
│   ├── modules/              # 功能模块
│   │   ├── users/
│   │   │   ├── users.module.ts
│   │   │   ├── users.controller.ts
│   │   │   ├── users.service.ts
│   │   │   └── users.spec.ts
│   │   └── ...
│   └── ...
├── package.json
├── tsconfig.json
└── nest-cli.json
```

### 4.3 库目录结构

```
libs/core/
├── src/
│   ├── index.ts              # 公共 API 导出
│   └── lib/                  # 功能模块目录
│       ├── user/             # 用户模块
│       │   ├── user.entity.ts        # 实体（Entity）
│       │   ├── user.service.ts       # 服务（Service）
│       │   ├── user.controller.ts    # 控制器（Controller）
│       │   ├── user.module.ts        # 模块定义
│       │   ├── repository/           # 仓储实现
│       │   │   ├── type-orm-user.repository.ts
│       │   │   └── mikro-orm-user.repository.ts
│       │   ├── commands/             # 命令
│       │   │   ├── user.create.command.ts
│       │   │   ├── user.delete.command.ts
│       │   │   └── handlers/
│       │   ├── queries/              # 查询（如有）
│       │   ├── dto/                  # 数据传输对象
│       │   └── user.spec.ts          # 单元测试
│       │
│       ├── tasks/            # 任务模块
│       ├── organization/      # 组织模块
│       ├── employee/         # 员工模块
│       │
│       ├── event-bus/        # 事件总线
│       │   ├── event-bus.ts
│       │   ├── event-bus.module.ts
│       │   ├── base-event.ts
│       │   └── events/
│       │
│       ├── database/         # 数据库配置
│       ├── core/             # 核心基础设施
│       │   ├── crud/         # CRUD 基类
│       │   ├── entities/     # 基础实体
│       │   └── repository/   # 基础仓储
│       │
│       └── shared/           # 共享工具
│
├── package.json
└── tsconfig.json
```

**目录结构特点**：
- 按功能模块组织，每个模块包含完整的三层结构
- Entity、Service、Controller 在同一模块目录下
- Repository 实现放在 `repository/` 子目录
- Commands 和 Queries 分别放在 `commands/` 和 `queries/` 子目录
- 共享的基础设施放在 `core/` 和 `shared/` 目录

---

## 5. 开发规范

### 5.1 代码规范

#### 命名规范

- **文件命名**: 使用 kebab-case（如 `user-service.ts`）
- **类命名**: 使用 PascalCase（如 `UserService`）
- **变量/函数命名**: 使用 camelCase（如 `getUserById`）
- **常量命名**: 使用 UPPER_SNAKE_CASE（如 `MAX_RETRY_COUNT`）
- **接口命名**: 使用 PascalCase，以 `I` 开头（如 `IUserRepository`）

#### 目录命名

- 使用 kebab-case
- 功能模块使用单数形式（如 `user` 而非 `users`）
- 共享目录使用复数形式（如 `entities`、`services`）

### 5.2 注释规范

#### TSDoc 注释要求

所有公共 API、类、方法、接口、枚举必须编写完整的 TSDoc 注释：

```typescript
/**
 * 用户服务类
 *
 * @description
 * 提供用户相关的业务逻辑处理，包括用户的创建、查询、更新和删除操作。
 * 本服务遵循 CQRS 模式，将命令和查询分离处理。
 *
 * @example
 * ```typescript
 * // 创建用户
 * const user = await userService.createUser({
 *   name: '张三',
 *   email: 'zhangsan@example.com'
 * });
 * ```
 *
 * @see {@link IUserRepository} 用户仓储接口
 * @see {@link UserEntity} 用户实体
 */
export class UserService {
  /**
   * 根据 ID 查询用户
   *
   * @description
   * 通过用户 ID 查询用户信息。如果用户不存在，将抛出 NotFoundException。
   *
   * @param {string} userId - 用户 ID
   * @returns {Promise<UserEntity>} 用户实体对象
   *
   * @throws {NotFoundException} 当用户不存在时抛出
   *
   * @example
   * ```typescript
   * const user = await userService.findById('user-123');
   * console.log(user.name); // 输出用户名称
   * ```
   */
  async findById(userId: string): Promise<UserEntity> {
    // 实现代码
  }
}
```

#### 注释语言

- **代码注释**: 必须使用中文
- **Git 提交信息**: 使用英文（遵循 Conventional Commits）
- **变量命名**: 使用英文，但必须配有中文注释说明业务语义

### 5.3 Git 提交规范

遵循 **Conventional Commits** 规范：

```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型（type）**:
- `feat`: 新功能
- `fix`: 修复 Bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建/工具相关

**示例**:
```
feat(auth): Add JWT token refresh endpoint

Add new endpoint /auth/refresh to refresh access tokens.
This allows clients to obtain new tokens without re-authentication.

Closes #123
```

### 5.4 分支管理

- `main`: 主分支，生产环境代码
- `develop`: 开发分支，集成最新功能
- `feature/*`: 功能分支
- `fix/*`: 修复分支
- `chore/*`: 工具/配置分支

---

## 6. API 设计规范

### 6.1 REST API 设计

#### URL 设计原则

- 使用名词，不使用动词
- 使用复数形式（如 `/users` 而非 `/user`）
- 使用层级结构表示资源关系（如 `/users/{id}/orders`）
- 使用查询参数进行过滤、排序、分页

#### HTTP 方法

| 方法 | 用途 | 示例 |
|------|------|------|
| GET | 查询资源 | `GET /users/{id}` |
| POST | 创建资源 | `POST /users` |
| PUT | 完整更新资源 | `PUT /users/{id}` |
| PATCH | 部分更新资源 | `PATCH /users/{id}` |
| DELETE | 删除资源 | `DELETE /users/{id}` |

#### 响应格式

**成功响应**:
```json
{
  "data": {
    "id": "user-123",
    "name": "张三",
    "email": "zhangsan@example.com"
  },
  "meta": {
    "timestamp": "2024-12-19T10:00:00Z"
  }
}
```

**错误响应**:
```json
{
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "用户不存在",
    "details": {
      "userId": "user-123"
    }
  },
  "meta": {
    "timestamp": "2024-12-19T10:00:00Z",
    "requestId": "req-456"
  }
}
```

#### 分页规范

```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "pageSize": 20,
    "total": 100,
    "totalPages": 5
  }
}
```

### 6.2 GraphQL API 设计

**功能状态**: ✅ **必需功能**（MVP 阶段必须实现）

GraphQL API 是本项目的核心功能之一，提供灵活的查询和变更接口。

#### Schema 定义

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Query {
  user(id: ID!): User
  users(page: Int, pageSize: Int): UserConnection!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
}
```

#### 查询示例

```graphql
query GetUser($id: ID!) {
  user(id: $id) {
    id
    name
    email
  }
}
```

---

## 7. 数据库设计

### 7.1 数据库选型

- **主数据库**: PostgreSQL >= 14.0
- **缓存**: Redis >= 6.0
- **ORM**: MikroORM（当前实现），保留 ORM 抽象层以便未来扩展 TypeORM

### 7.2 命名规范

- **表名**: 使用 snake_case，复数形式（如 `users`、`user_roles`）
- **字段名**: 使用 snake_case（如 `created_at`、`user_id`）
- **索引名**: `idx_{table}_{column}`（如 `idx_users_email`）
- **外键名**: `fk_{table}_{referenced_table}`（如 `fk_user_roles_users`）

### 7.3 实体设计规范

#### 实体继承层次

所有实体应继承相应的基类，实现多租户支持和通用字段：

```
BaseEntity
  ├── id: ID (UUID)
  ├── createdAt: Date
  ├── updatedAt: Date
  └── deletedAt?: Date (软删除)

TenantBaseEntity extends BaseEntity
  ├── tenant?: Tenant
  └── tenantId?: ID

TenantOrganizationBaseEntity extends TenantBaseEntity
  ├── organization?: Organization
  └── organizationId?: ID
```

#### 实体定义示例

**基础实体**：

```typescript
/**
 * 基础实体类
 *
 * @description
 * 所有实体的基类，提供通用字段（ID、时间戳、软删除）。
 */
export abstract class BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  id: ID;

  @MultiORMColumn({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  createdAt: Date;

  @MultiORMColumn({ 
    type: 'timestamp', 
    default: () => 'CURRENT_TIMESTAMP',
    onUpdate: 'CURRENT_TIMESTAMP'
  })
  updatedAt: Date;

  @MultiORMColumn({ type: 'timestamp', nullable: true })
  deletedAt?: Date;
}
```

**多租户实体**：

```typescript
/**
 * 用户实体
 *
 * @description
 * 表示系统中的用户，包含用户的基本信息和认证信息。
 * 继承 TenantBaseEntity 实现多租户数据隔离。
 */
@MultiORMEntity('users', { 
  mikroOrmRepository: () => MikroOrmUserRepository 
})
export class User extends TenantBaseEntity {
  /**
   * 用户邮箱
   *
   * @description 用户的邮箱地址，用于登录和通知，必填且唯一
   */
  @MultiORMColumn({ type: 'varchar', length: 255, unique: true })
  email: string;

  /**
   * 用户名称
   *
   * @description 用户的显示名称，必填，长度限制 1-100 字符
   */
  @MultiORMColumn({ type: 'varchar', length: 100 })
  name: string;

  // ... 其他字段
}
```

#### 实体装饰器

- **@MultiORMEntity**: 定义实体，当前适配 MikroORM，抽象层支持未来扩展 TypeORM
- **@MultiORMColumn**: 定义列，当前适配 MikroORM，自动适配不同 ORM
- **@MultiORMManyToOne**: 定义多对一关系
- **@MultiORMOneToMany**: 定义一对多关系
- **@MultiORMManyToMany**: 定义多对多关系

### 7.4 迁移管理

- 使用 MikroORM 的迁移功能（当前实现）
- 迁移抽象层已预留，未来可扩展支持 TypeORM 迁移
- 迁移文件命名: `{timestamp}-{description}.ts`
- 每次迁移必须可回滚
- 迁移脚本需包含中文注释说明

---

## 8. 测试策略

### 8.1 测试分层

#### 单元测试

- **位置**: 与被测文件同目录，命名 `{filename}.spec.ts`
- **覆盖率要求**: 核心业务逻辑 80%+，关键路径 90%+
- **测试内容**: 业务逻辑、工具函数、服务方法

```typescript
describe('UserService', () => {
  describe('findById', () => {
    it('应该返回指定 ID 的用户', async () => {
      // 测试代码
    });

    it('当用户不存在时应该抛出 NotFoundException', async () => {
      // 测试代码
    });
  });
});
```

#### 集成测试

- **位置**: `tests/integration/`
- **测试内容**: 数据库操作、外部服务调用、模块间交互

#### 端到端测试

- **位置**: `tests/e2e/`
- **测试内容**: 完整的 API 请求流程

### 8.2 测试工具

- **测试框架**: Jest
- **断言库**: Jest 内置断言
- **Mock 工具**: Jest Mock
- **测试数据库**: PostgreSQL（使用测试数据库）

### 8.3 测试覆盖率

- 核心业务逻辑: >= 80%
- 关键路径: >= 90%
- 所有公共 API: 100%

---

## 9. 安全规范

### 9.1 认证授权

#### 9.1.1 认证方式

- **认证方式**: JWT（JSON Web Token）
- **Token 类型**: Access Token + Refresh Token
- **Token 存储**: 
  - Access Token：存储在内存或 localStorage（客户端）
  - Refresh Token：存储在 HttpOnly Cookie（更安全）
- **密码加密**: 使用 bcrypt，salt rounds >= 10

#### 9.1.2 认证流程

1. **用户登录** → 验证用户名和密码
2. **生成 Token** → 生成 JWT Access Token 和 Refresh Token
3. **存储 Token** → Access Token 返回给客户端，Refresh Token 存储在 Cookie
4. **请求验证** → AuthGuard 验证 Access Token
5. **Token 刷新** → 使用 Refresh Token 获取新的 Access Token

#### 9.1.3 授权机制

**基于角色的访问控制（RBAC）**：

```typescript
/**
 * 权限枚举
 */
export enum PermissionsEnum {
  USER_VIEW = 'USER_VIEW',
  USER_CREATE = 'USER_CREATE',
  USER_EDIT = 'USER_EDIT',
  USER_DELETE = 'USER_DELETE',
  // ... 其他权限
}

/**
 * 权限守卫
 */
@Injectable()
export class PermissionGuard implements CanActivate {
  constructor(
    private readonly reflector: Reflector,
    private readonly rolePermissionService: RolePermissionService
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPermissions = this.reflector.get<PermissionsEnum[]>(
      'permissions',
      context.getHandler()
    );

    if (!requiredPermissions) {
      return true;
    }

    const user = RequestContext.currentUser();
    if (!user) {
      throw new UnauthorizedException();
    }

    // 检查用户权限
    for (const permission of requiredPermissions) {
      const hasPermission = await this.rolePermissionService.hasPermission(
        user.id,
        permission
      );
      if (!hasPermission) {
        throw new ForbiddenException(`缺少权限: ${permission}`);
      }
    }

    return true;
  }
}
```

**权限装饰器使用**：

```typescript
@Controller('users')
export class UserController {
  @Get()
  @UseGuards(PermissionGuard)
  @Permissions(PermissionsEnum.USER_VIEW)
  async findAll() {
    // 需要 USER_VIEW 权限
  }

  @Post()
  @UseGuards(PermissionGuard)
  @Permissions(PermissionsEnum.USER_CREATE)
  async create(@Body() dto: CreateUserDTO) {
    // 需要 USER_CREATE 权限
  }
}
```

#### 9.1.4 多租户隔离

- **租户识别**: 从 JWT Token 或 Header 获取 `tenantId`
- **数据过滤**: Repository 自动添加租户过滤条件
- **上下文管理**: RequestContext 存储当前租户信息
- **权限隔离**: 用户只能访问所属租户的数据

### 9.2 API 安全

- **HTTPS**: 生产环境必须使用 HTTPS
- **CORS**: 配置适当的 CORS 策略
- **Rate Limiting**: 实现请求频率限制
- **输入验证**: 使用 class-validator 验证所有输入
- **SQL 注入防护**: 使用 ORM 参数化查询

### 9.3 数据安全

- **敏感数据加密**: 密码、密钥等敏感数据必须加密存储
- **日志脱敏**: 日志中不包含敏感信息
- **数据备份**: 定期备份数据库

---

## 10. 构建和部署

### 10.1 构建配置

#### Turbo 任务配置

```json
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": ["coverage/**"]
    },
    "start:dev": {
      "cache": false,
      "persistent": true,
      "dependsOn": ["build"]
    }
  }
}
```

#### 构建命令

```bash
# 构建所有包
pnpm build

# 运行测试
pnpm test

# 开发模式启动
pnpm dev

# 生产模式启动
pnpm prod
```

### 10.2 环境配置

#### 环境变量

- 使用 `.env` 文件管理环境变量
- 不同环境使用不同的 `.env` 文件（`.env.development`、`.env.production`）
- 敏感信息使用环境变量，不提交到代码库

**必需环境变量清单**（参考 ever-gauzy）：

| 环境变量 | 说明 | 示例值 | 必需 |
|---------|------|--------|------|
| `API_HOST` | API 主机地址 | `0.0.0.0` | ✅ |
| `API_PORT` | API 端口号 | `3000` | ✅ |
| `API_BASE_URL` | API 基础 URL | `http://localhost:3000` | ✅ |
| `DB_HOST` | 数据库主机 | `localhost` | ✅ |
| `DB_PORT` | 数据库端口 | `5432` | ✅ |
| `DB_NAME` | 数据库名称 | `oksai` | ✅ |
| `DB_USER` | 数据库用户名 | `postgres` | ✅ |
| `DB_PASSWORD` | 数据库密码 | `password` | ✅ |
| `DB_ORM` | ORM 类型 | `mikro-orm` | ✅ |
| `JWT_SECRET` | JWT 密钥 | `secretKey` | ✅ |
| `JWT_REFRESH_TOKEN_SECRET` | JWT 刷新令牌密钥 | `refreshSecretKey` | ✅ |
| `EXPRESS_SESSION_SECRET` | Express Session 密钥 | `gauzy` | ✅ |
| `REDIS_URL` | Redis 连接 URL | `redis://localhost:6379` | ⚠️ |
| `OTEL_ENABLED` | 启用 OpenTelemetry | `false` | ❌ |
| `OTEL_EXPORTER_OTLP_TRACES_ENDPOINT` | OpenTelemetry 端点 | `http://localhost:14268/api/traces` | ❌ |
| `SENTRY_DSN` | Sentry DSN | - | ❌ |
| `POSTHOG_KEY` | PostHog API Key | - | ❌ |
| `POSTHOG_ENABLED` | 启用 PostHog | `false` | ❌ |

**说明**：
- ✅ 必需：应用运行必需的环境变量
- ⚠️ 条件必需：某些功能（如 Session 存储）需要
- ❌ 可选：可选功能的环境变量

#### 配置管理

```typescript
// libs/config/src/config.module.ts
@Module({
  providers: [
    {
      provide: ConfigService,
      useFactory: () => {
        return {
          database: {
            host: process.env.DB_HOST,
            port: parseInt(process.env.DB_PORT),
            // ...
          },
          // ...
        };
      },
    },
  ],
})
export class ConfigModule {}
```

### 10.3 容器化

#### Dockerfile

```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install
COPY . .
RUN pnpm build

FROM node:20-alpine AS runner
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package.json ./
CMD ["node", "dist/apps/api/main.js"]
```

#### Docker Compose

```yaml
version: '3'
services:
  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - db
      - redis

  db:
    image: postgres:14
    environment:
      - POSTGRES_DB=oksai
      - POSTGRES_USER=oksai
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine
    volumes:
      - redis_data:/data
```

### 10.4 部署流程

1. **代码提交**: 推送到 Git 仓库
2. **CI/CD**: 自动触发构建和测试
3. **构建镜像**: 构建 Docker 镜像
4. **部署**: 部署到生产环境
5. **健康检查**: 验证服务是否正常启动

---

## 11. 监控和日志

### 11.1 日志规范

**日志实现**（参考 ever-gauzy）：

- **基础日志**: 基于 NestJS `LoggerService` 的默认日志实现
- **日志级别**: ERROR、WARN、INFO、DEBUG、VERBOSE
- **日志格式**: 控制台输出，包含时间戳、级别、上下文、消息
- **外部日志服务**: 通过插件系统集成 Sentry、PostHog 等（可选）

**日志实现示例**（参考 ever-gauzy 的 DefaultLogger）：

```typescript
import { LoggerService } from '@nestjs/common';

export class DefaultLogger implements LoggerService {
  log(message: any, context?: string) {
    console.log(`[INFO] [${context || 'Bootstrap'}] ${message}`);
  }

  error(message: string, context?: string, trace?: string) {
    console.error(`[ERROR] [${context || 'Bootstrap'}] ${message}`);
    if (trace) console.error(trace);
  }

  warn(message: string, context?: string) {
    console.warn(`[WARN] [${context || 'Bootstrap'}] ${message}`);
  }

  info(message: string, context?: string) {
    console.info(`[INFO] [${context || 'Bootstrap'}] ${message}`);
  }

  debug(message: string, context?: string) {
    console.debug(`[DEBUG] [${context || 'Bootstrap'}] ${message}`);
  }

  verbose(message: string, context?: string) {
    console.log(`[VERBOSE] [${context || 'Bootstrap'}] ${message}`);
  }
}
```

**使用示例**：

```typescript
logger.info('用户登录成功', 'UserController');
logger.error('登录失败', 'AuthService', error.stack);
```

### 11.2 监控和追踪

**OpenTelemetry 支持**（参考 ever-gauzy）：

- **启用方式**: 通过环境变量 `OTEL_ENABLED=true` 启用
- **追踪提供者**: 支持 Jaeger、Honeycomb、Aspecto 等
- **自动插桩**: 自动插桩 HTTP、Express、NestJS、Redis、PostgreSQL 等
- **导出方式**: OTLP (HTTP/gRPC)、Zipkin、Console

**配置示例**：

```typescript
// 环境变量配置
OTEL_ENABLED=true
OTEL_PROVIDER=jaeger  // jaeger | honeycomb | aspecto
OTEL_EXPORTER_OTLP_TRACES_ENDPOINT=http://localhost:14268/api/traces
OTEL_SERVICE_NAME=oksai-api
```

**监控指标**：

- **应用指标**: 请求数、响应时间、错误率
- **系统指标**: CPU、内存、磁盘使用率
- **业务指标**: 用户数、订单数等业务指标

### 11.3 健康检查

```typescript
@Controller('health')
export class HealthController {
  @Get()
  async check() {
    return {
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
    };
  }
}
```

---

## 12. 性能优化

### 12.1 数据库优化

- **索引优化**: 为常用查询字段创建索引
- **查询优化**: 避免 N+1 查询，使用关联查询
- **连接池**: 配置适当的数据库连接池大小
- **缓存策略**: 使用 Redis 缓存热点数据

### 12.2 API 优化

- **分页**: 所有列表接口必须支持分页
- **字段选择**: GraphQL 支持字段选择，REST API 支持字段过滤
- **压缩**: 启用响应压缩（gzip）
- **CDN**: 静态资源使用 CDN

### 12.3 缓存策略

- **查询缓存**: 缓存频繁查询的数据
- **会话缓存**: 使用 Redis 存储会话信息
- **缓存失效**: 实现合理的缓存失效策略

---

## 13. 扩展性设计

### 13.1 水平扩展

- **无状态设计**: API 服务设计为无状态，支持水平扩展
- **负载均衡**: 使用负载均衡器分发请求
- **数据库扩展**: 支持读写分离、分库分表

### 13.2 插件系统

**功能状态**: ✅ **必需功能**（MVP 阶段必须实现）

插件系统是本项目的核心功能之一，支持通过插件机制扩展应用功能，实现模块化和可扩展的架构。

#### 13.2.1 插件架构

**插件接口定义**：

```typescript
export interface IPlugin {
  name: string;
  version: string;
  entities?: Array<Type<any>>;
  subscribers?: Array<Type<EntitySubscriberInterface>>;
  configuration?: (
    config: ApplicationPluginConfig
  ) => Promise<ApplicationPluginConfig>;
}
```

**插件配置**：

```typescript
// apps/api/src/plugin-config.ts
export const pluginConfig: Partial<ApplicationPluginConfig> = {
  plugins: [
    SentryPlugin,
    PostHogPlugin,
    // ... 其他插件
  ]
};
```

#### 13.2.2 插件注册流程

1. **预引导阶段**：
   - 注册插件实体（检查冲突）
   - 注册插件订阅者（检查冲突）
   - 应用插件配置函数

2. **启动阶段**：
   - 加载插件 NestJS 模块
   - 注册插件服务
   - 初始化插件功能

#### 13.2.3 插件开发

**插件示例**：

```typescript
@Plugin({
  name: 'sentry-plugin',
  version: '1.0.0'
})
export class SentryPlugin implements IPlugin {
  entities = [SentryEventEntity];
  subscribers = [SentrySubscriber];
  
  async configuration(config: ApplicationPluginConfig) {
    // 应用 Sentry 配置
    if (process.env.SENTRY_DSN) {
      config.dbConnectionOptions = {
        ...config.dbConnectionOptions,
        // Sentry 特定配置
      };
    }
    return config;
  }
}
```

#### 13.2.4 插件隔离

- **实体隔离**: 插件实体与核心实体隔离，避免冲突
- **服务隔离**: 插件服务通过依赖注入管理
- **配置隔离**: 插件配置独立管理，不影响核心配置

---

## 14. 附录

### 14.1 参考文档

- [NestJS 官方文档](https://docs.nestjs.com/)
- [TypeORM 文档](https://typeorm.io/)
- [MikroORM 文档](https://mikro-orm.io/)
- [Turbo 官方文档](https://turbo.build/repo/docs)
- [CQRS 模式](https://martinfowler.com/bliki/CQRS.html)
- [事件驱动架构](https://martinfowler.com/articles/201701-event-driven.html)

### 14.2 相关文档

- XS-001: 可行性分析报告
- XS-003: ever-gauzy 架构设计分析
- 项目章程: `.cursor/rules/项目章程.mdc`

### 14.3 术语表

- **三层架构**: Controller-Service-Repository 架构模式，传统的分层架构
- **CQRS**: Command Query Responsibility Segregation，命令查询职责分离
  - Command：写操作，通过 Command Handlers 处理
  - Query：读操作，通过 Query Handlers 处理
- **EDA**: Event-Driven Architecture，事件驱动架构
  - 通过事件总线实现发布-订阅模式
  - 支持跨模块的异步事件通信
  - 事件仅在内存中流转（如 ever-gauzy 的实现）
- **多租户（Multi-Tenant）**: 单个应用实例为多个租户提供服务，数据隔离
  - TenantBaseEntity：多租户实体基类，包含 tenantId 字段
  - TenantOrganizationBaseEntity：多租户组织实体基类，包含 tenantId 和 organizationId
- **CLS**: Continuation Local Storage，延续本地存储
  - 用于管理请求级数据（如用户、租户信息）
  - 使用 nestjs-cls 实现
- **ORM 抽象层**: 提供统一的 ORM 抽象接口，屏蔽不同 ORM 的差异
  - 当前实现：仅支持 MikroORM
  - 未来扩展：通过抽象层可扩展支持 TypeORM
  - 设计目标：保留抽象层作为扩展点，便于未来切换或同时支持多个 ORM
- **Monorepo**: 将多个相关项目放在同一个代码仓库中的开发方式
- **ORM**: Object-Relational Mapping，对象关系映射
- **DTO**: Data Transfer Object，数据传输对象
- **Entity**: 实体，表示数据库表的映射对象，直接继承 ORM 基类
- **Repository**: 仓储，封装数据访问逻辑，提供统一的数据访问接口
- **RBAC**: Role-Based Access Control，基于角色的访问控制
- **JWT**: JSON Web Token，用于认证的令牌
- **Bootstrap**: 应用启动流程，包括配置、中间件、数据库初始化等
- **插件系统**: 支持功能模块的插件化扩展，通过配置文件管理插件

---

## 15. 审批记录

| 角色 | 姓名 | 日期 | 意见 | 签名 |
|------|------|------|------|------|
| 技术负责人 | | | | |
| 架构师 | | | | |
| 项目经理 | | | | |

---

**文档结束**
